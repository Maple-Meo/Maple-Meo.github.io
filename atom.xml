<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Maplemeo</title>
  
  
  <link href="https://maple-meo.github.io/atom.xml" rel="self"/>
  
  <link href="https://maple-meo.github.io/"/>
  <updated>2023-05-10T12:56:13.722Z</updated>
  <id>https://maple-meo.github.io/</id>
  
  <author>
    <name>Maplemeo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何实现一个简单的含有输入参数的Hello内核模块，并在其中实现单链表</title>
    <link href="https://maple-meo.github.io/posts/4a17b1554/"/>
    <id>https://maple-meo.github.io/posts/4a17b1554/</id>
    <published>2023-05-10T11:41:06.065Z</published>
    <updated>2023-05-10T12:56:13.722Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何实现一个简单的含有输入参数的hello内核模块并在其中实现单链表"><a class="markdownIt-Anchor" href="#如何实现一个简单的含有输入参数的hello内核模块并在其中实现单链表"></a> 如何实现一个简单的含有输入参数的Hello内核模块，并在其中实现单链表</h1><h2 id="linux内核模块编程"><a class="markdownIt-Anchor" href="#linux内核模块编程"></a> Linux内核模块编程</h2><p>这篇文章的目的是使个人：</p><p>1.熟悉操作系统内核编程开发环境</p><p>2.初步掌握Linux环境下内核模块编写、编译、调试及运行的基本流程</p><p>3.熟悉内核编程的基本方法和步骤</p><h3 id="编程环境"><a class="markdownIt-Anchor" href="#编程环境"></a> 编程环境</h3><p>VMware Workstation Pro + Ubuntu 16.04 LTS</p><p>VMware+Ubuntu 16.04 LTS虚拟机安装教程参考：</p><p><a href="https://zhuanlan.zhihu.com/p/426795684">2021安装Vmware和Ubuntu教程(特详细) - 知乎 (zhihu.com)</a></p><p>其中Ubuntu 16.04 LTS镜像下载参考：</p><p><a href="https://blog.csdn.net/dongjuexk/article/details/109334673">(39条消息) ubuntu 16.04 镜像下载（国内开源镜像站）_ubtun16.04_dongjuexk的博客-CSDN博客</a></p><h3 id="什么是内核模块"><a class="markdownIt-Anchor" href="#什么是内核模块"></a> 什么是内核模块？</h3><p>内核模块的全称是动态可加载内核模块(Loadable Kernel Modul,KLM)，可以动态载入内核，让它成为内核代码的一部分。一个模块一般由一组函数和数据结构组成。</p><h3 id="模块要求"><a class="markdownIt-Anchor" href="#模块要求"></a> 模块要求</h3><p>1.Ubuntu 16.04环境下实现含输入参数的Hello内核模块，可以按照输入的打印行数及姓名输出相应的信息。</p><p>2.在模块中实现单链表，完成insert、delete、lookup、print操作</p><h3 id="如何编写带有输入参数的最简单的hello-world模块"><a class="markdownIt-Anchor" href="#如何编写带有输入参数的最简单的hello-world模块"></a> 如何编写带有输入参数的最简单的Hello World模块</h3><p>打开终端，创建项目文件夹Linux-expr，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir Linux-expr </span><br><span class="line"></span><br><span class="line">cd Linux-expr</span><br></pre></td></tr></table></figure><p>创建hello.c文件，文件内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/module.h&gt;</span>   <span class="comment">//每个模块都要包括的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/kernel.h&gt;</span>  <span class="comment">//使用到了printk()函数进行输出</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/moduleparam.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);    <span class="comment">//没有指定license会出现error</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span>*whom = <span class="string">&quot;world&quot;</span>; </span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> num = <span class="number">1</span>;      <span class="comment">//定义静态变量使变量只被当前文件访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//传递命令参数 S_IRUGO 指明参数可以被所有人读取 </span></span><br><span class="line"></span><br><span class="line">module_param(whom,charp,S_IRUGO);</span><br><span class="line"></span><br><span class="line">module_param(num,<span class="type">int</span>,S_IRUGO);</span><br><span class="line"></span><br><span class="line"><span class="comment">//作为驱动模块的加载函数，将相应的驱动模块hello_init加载到Linux内核中，相当于普通文件的c函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">  <span class="comment">//只能使用内核里定义好的C函数，printk会根据日志级别将指定信息输出到控制台或日志文件中，KERN_ALERT会输出到控制台</span></span><br><span class="line">   printk(KERN_ALERT <span class="string">&quot;hello,%s\n&quot;</span>,whom);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将已存在的驱动模块hello_exit从内核中卸载</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  printk(KERN_ALERT <span class="string">&quot;goodbye,kernel/n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载or卸载模块</span></span><br><span class="line"></span><br><span class="line">module_init(hello_init);</span><br><span class="line"></span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选的一些属性 </span></span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Maplemeo-silence&quot;</span>);</span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;This is a simple example!/n&quot;</span>);</span><br><span class="line"></span><br><span class="line">MODULE_VERSION(<span class="string">&quot;v1.0&quot;</span>);</span><br><span class="line"></span><br><span class="line">MODULE_ALIAS(<span class="string">&quot;A simplest example&quot;</span>);</span><br></pre></td></tr></table></figure><p>创建makefile文件，内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">obj-m:=hello.o</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CURRENT_PATH :=$(shell pwd)</span><br><span class="line">VERSION_NUM :=$(shell uname -r)</span><br><span class="line">LINUX_PATH :=/usr/src/linux-headers-$(VERSION_NUM)</span><br><span class="line"></span><br><span class="line">all :</span><br><span class="line">    make -C $(LINUX_PATH) M=$(CURRENT_PATH) modules</span><br><span class="line">clean :</span><br><span class="line">    make -C $(LINUX_PATH) M=$(CURRENT_PATH) clean</span><br></pre></td></tr></table></figure><p>通过make命令，编译文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>可以看到目录下出现以下文件，其中hello.ko文件为我们所需要的内核模块文件：</p><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305102011827.png" alt="image-20230510201153770" style="zoom:50%;" /><p>使用insmod <moudlename>命令加载模块（使用sudo权限）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo insmod hello.ko</span><br></pre></td></tr></table></figure><p>使用lsmod查看模块是否加载进去，可以看到hello已经可以看到</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lsmod</span><br></pre></td></tr></table></figure><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305102017534.png" alt="image-20230510201738501" style="zoom: 67%;" /><p>使用demesg命令查看输出，可以看到有hello，world的输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo demesg</span><br></pre></td></tr></table></figure><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305102019683.png" alt="image-20230510201956647" style="zoom:67%;" /><p>最后使用rmmod <moudlename>命令卸载模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rmmod hello</span><br></pre></td></tr></table></figure><h3 id="如何编在模块中实现单链表"><a class="markdownIt-Anchor" href="#如何编在模块中实现单链表"></a> 如何编在模块中实现单链表</h3><p>内核模块中实现单链表和在普通c程序中相差不多，值得注意的是，内存分配还是malloc被kmalloc所替换</p><p>listnode结构体如下所示，就是最简单的单链表结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listnode</span>&#123;</span>  </span><br><span class="line">  <span class="type">int</span> val_; <span class="comment">//data</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">listnode</span>* <span class="title">next_</span>;</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>hello.c文件改写为如下内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span>*whom = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listnode</span>&#123;</span>  </span><br><span class="line">   <span class="type">int</span> val_;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">listnode</span>* <span class="title">next_</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> val,<span class="keyword">struct</span> listnode* head)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">      printk(KERN_ALERT <span class="string">&quot;the head is null, can not insert\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">struct</span> listnode* curr;</span><br><span class="line">      curr = head;</span><br><span class="line">      <span class="type">int</span> num;</span><br><span class="line">      num = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(curr-&gt;next_!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">         curr = curr-&gt;next_;</span><br><span class="line">         num++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">listnode</span> *<span class="title">new_node</span>;</span></span><br><span class="line">      new_node=kmalloc(<span class="keyword">sizeof</span>(*new_node),GFP_KERNEL);</span><br><span class="line">      new_node-&gt;val_ = val;</span><br><span class="line">      new_node-&gt;next_ = <span class="literal">NULL</span>;</span><br><span class="line">      curr-&gt;next_ = new_node;</span><br><span class="line">      printk(KERN_ALERT <span class="string">&quot;insert success!!! the new %d val = %d\n&quot;</span>,num,new_node-&gt;val_);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="keyword">struct</span> listnode* head)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">      printk(KERN_ALERT <span class="string">&quot;the head is null, can not printf\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">int</span> num;</span><br><span class="line">   num = <span class="number">0</span>;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">listnode</span>* <span class="title">curr</span>;</span></span><br><span class="line">   curr = head;</span><br><span class="line">   printk(KERN_ALERT <span class="string">&quot;---------List Print--------\n&quot;</span>);</span><br><span class="line">   <span class="keyword">while</span>(curr-&gt;next_!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      curr = curr-&gt;next_;</span><br><span class="line">      printk(KERN_ALERT <span class="string">&quot;the %d val = %d\n&quot;</span>,num,curr-&gt;val_);</span><br><span class="line">      num++;</span><br><span class="line">   &#125;</span><br><span class="line">   printk(KERN_ALERT <span class="string">&quot;-------List Print end--------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> val,<span class="keyword">struct</span> listnode* head)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">      printk(KERN_ALERT <span class="string">&quot;the head is null, can not delete\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">listnode</span>* <span class="title">curr</span>;</span></span><br><span class="line">   curr = head;</span><br><span class="line">   <span class="type">int</span> num;</span><br><span class="line">   num = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(curr-&gt;next_ != <span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">listnode</span>* <span class="title">prev</span>;</span></span><br><span class="line">      prev = curr;</span><br><span class="line">      curr = curr-&gt;next_;</span><br><span class="line">      <span class="keyword">if</span>(curr-&gt;val_ == val)&#123;</span><br><span class="line">         prev-&gt;next_ = curr-&gt;next_;</span><br><span class="line">         kfree(curr); <span class="comment">//使用kfree，而不是free</span></span><br><span class="line">         printk(KERN_ALERT <span class="string">&quot;delete success!!! the delete %d val = %d\n&quot;</span>,num,val);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      num++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   printk(KERN_ALERT <span class="string">&quot;delete fail!!! can not find val = %d\n&quot;</span>,val);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lookup</span><span class="params">(<span class="type">int</span> val,<span class="keyword">struct</span> listnode* head)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">      printk(KERN_ALERT <span class="string">&quot;the head is null, can not delete\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">listnode</span>* <span class="title">curr</span>;</span></span><br><span class="line">   curr = head;</span><br><span class="line">   <span class="type">int</span> num;</span><br><span class="line">   num = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(curr-&gt;next_ != <span class="literal">NULL</span>)&#123;</span><br><span class="line">      curr = curr-&gt;next_;</span><br><span class="line">      <span class="keyword">if</span>(curr-&gt;val_ == val)&#123;</span><br><span class="line">         printk(KERN_ALERT <span class="string">&quot;lookup success!!! the lookup %d val = %d\n&quot;</span>,num,curr-&gt;val_ );</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      num++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   printk(KERN_ALERT <span class="string">&quot;lookup fail!!! can not lookup val = %d\n&quot;</span>,curr-&gt;val_);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//传递命令参数 S_IRUGO 指明参数可以被所有人读取 </span></span><br><span class="line">module_param(whom,charp,S_IRUGO);</span><br><span class="line">module_param(num,<span class="type">int</span>,S_IRUGO);</span><br><span class="line"></span><br><span class="line"><span class="comment">//程序中必须有下列两个函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">   <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">   <span class="comment">//使用的是printk 不是printf（其是C库函数）</span></span><br><span class="line">      printk(KERN_ALERT <span class="string">&quot;hello,%s\n&quot;</span>,whom);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//创建头节点</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">listnode</span> *<span class="title">head</span>;</span></span><br><span class="line">    <span class="comment">//使用的是kmalloc 不是malloc（其是C库函数）</span></span><br><span class="line">   head=kmalloc(<span class="keyword">sizeof</span>(*head),GFP_KERNEL);</span><br><span class="line">   <span class="keyword">if</span>(head != <span class="literal">NULL</span>)&#123;</span><br><span class="line">   head-&gt;val_ = <span class="number">0</span>;</span><br><span class="line">   head-&gt;next_ = <span class="literal">NULL</span>;</span><br><span class="line">   printk(KERN_ALERT <span class="string">&quot;the head val: %d\n&quot;</span>,head-&gt;val_);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//进行测试操作</span></span><br><span class="line">   print(head); <span class="comment">//打印操作</span></span><br><span class="line">   insert(<span class="number">7</span>,head); <span class="comment">//插入操作</span></span><br><span class="line">   print(head);</span><br><span class="line">   delete(<span class="number">2</span>,head); <span class="comment">//删除操作</span></span><br><span class="line">   print(head);</span><br><span class="line">   insert(<span class="number">1</span>,head);</span><br><span class="line">   insert(<span class="number">5</span>,head);</span><br><span class="line">   print(head);</span><br><span class="line">   delete(<span class="number">1</span>,head);</span><br><span class="line">   lookup(<span class="number">7</span>,head); <span class="comment">//查找操作</span></span><br><span class="line">   print(head);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   printk(KERN_ALERT <span class="string">&quot;goodbye,kernel/n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载or卸载模块</span></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"><span class="comment">// 可选 </span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Maplemeo-silence&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;This is a simple example!/n&quot;</span>);</span><br><span class="line">MODULE_VERSION(<span class="string">&quot;v1.0&quot;</span>);</span><br><span class="line">MODULE_ALIAS(<span class="string">&quot;A simplest example&quot;</span>);</span><br></pre></td></tr></table></figure><p>使用make、insmod、demesg、 rmmod命令查看链表是否正常使用，至此整个内核模块实现完成。</p><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305102035484.png" alt="image-20230510203504418" style="zoom:67%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何实现一个简单的含有输入参数的hello内核模块并在其中实现单链表&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#如何实现一个简单的含有输入参数的hello内核模块并在其中实现单链表&quot;&gt;&lt;/a&gt; 如何实现一个简单的含有输入参数的Hel</summary>
      
    
    
    
    <category term="一些教程" scheme="https://maple-meo.github.io/categories/%E4%B8%80%E4%BA%9B%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="操作系统" scheme="https://maple-meo.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="内存模块编程" scheme="https://maple-meo.github.io/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9D%97%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Maplemeo Git 常用命令学习笔记</title>
    <link href="https://maple-meo.github.io/posts/4a17b1551/"/>
    <id>https://maple-meo.github.io/posts/4a17b1551/</id>
    <published>2023-05-07T04:31:58.681Z</published>
    <updated>2023-05-07T07:25:14.236Z</updated>
    
    <content type="html"><![CDATA[<h1 id="maplemeo-git-常用命令学习笔记"><a class="markdownIt-Anchor" href="#maplemeo-git-常用命令学习笔记"></a> Maplemeo Git 常用命令学习笔记</h1><p>学习参考视频：</p><p><a href="https://b23.tv/u8yad2p?share_medium=android&amp;share_source=qq&amp;bbid=XY3F3A53DAE83FB5DF7950A12C736D2FEAE6B&amp;ts=1682349632635">Git工作流和核心原理 | GitHub基本操作 | VS Code里使用Git和关联GitHub_哔哩哔哩_bilibili</a></p><p>Git环境配置</p><p>查看配置信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config -l</span><br></pre></td></tr></table></figure><p>查看系统配置信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --system --list</span><br></pre></td></tr></table></figure><p>查看全局配置信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --list</span><br></pre></td></tr></table></figure><p>配置个人信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global [user.name](http://user.name/) &quot;maplemeo&quot;</span><br><span class="line">git config --global user.email &quot;[913439694@qq.com](mailto:913439694@qq.com)&quot;</span><br></pre></td></tr></table></figure><p><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305071307231.png" alt="img" /></p><p>对目标文件夹进行初始化操作，告诉git此文件夹需要进行版本控制操作，初始化后，默认处于主分支（master）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305071308993.png" alt="img" /></p><p>创建一个测试文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;版本一&quot; &gt; [lao.md](http://lao.md/)</span><br></pre></td></tr></table></figure><p>查看当前状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305071309865.png" alt="img" /></p><p>将lao.md文件添加到缓冲区，并查看状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add lao.md</span><br><span class="line"></span><br><span class="line">git status</span><br></pre></td></tr></table></figure><p><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305071309651.png" alt="img" /></p><p>可以看到，提示可以进行commit提交</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure><p><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305071310621.png" alt="img" /></p><p>此时会出现conmmit文件信息，可以在第一行添加”版本1“作为conmmit的说明</p><p>提交完成后，使用git status查看状态</p><p><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305071311250.png" alt="Untitled 5" /></p><p><a href="http://xn--lao-p18dz4nl3alww87c1x2b684c.md">添加一行内容到lao.md</a></p><p><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305071311944.png" alt="Untitled 6" /></p><p>将lao.md文件添加到缓冲区，并查看状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add lao.md</span><br></pre></td></tr></table></figure><p>使用-m参数可以直接添加信息，不进入COMMIT文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;版本二”</span><br></pre></td></tr></table></figure><p><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305071311166.png" alt="Untitled 7" /></p><p>查看版本提交日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><p><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305071312671.png" alt="Untitled 8" /></p><p>创建忽略追踪分支文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch .gitignore</span><br></pre></td></tr></table></figure><p>在gitignore文件里面可以添加需要忽略追踪的文件名</p><p>创建新分支使用git branch 新分支名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch oneuse</span><br></pre></td></tr></table></figure><p>查看分支是否创建成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305071312437.png" alt="Untitled 9" /></p><p>切换到新分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout oneuse</span><br></pre></td></tr></table></figure><p><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305071312834.png" alt="Untitled 10" /></p><p>回到master</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p>删除新分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d oneuse</span><br></pre></td></tr></table></figure><p><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305071312658.png" alt="Untitled 11" /></p><p>如果新分支有修改，使用-d会出现提示，如果确定删除分支，建议使用-D删除分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D oneuse</span><br></pre></td></tr></table></figure><p>创建新分支并直接跳转</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b newuse</span><br></pre></td></tr></table></figure><p><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305071313542.png" alt="Untitled 12" /></p><p>修改lao.md文件，并add和commit</p><p><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305071313622.png" alt="Untitled 13" /></p><p><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305071313476.png" alt="Untitled 14" /></p><p>将分支修改合并到master上面，可以看到master的lao.md文件已经修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line">git merge newuse</span><br></pre></td></tr></table></figure><p><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305071322595.png" alt="Untitled 15" /></p><p><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305071318677.png" alt="Untitled 16" /></p>]]></content>
    
    
    <summary type="html">这是一篇给计算机小白初学Git的分享笔记，里面包含了常见Git命令的使用和实例~</summary>
    
    
    
    <category term="一些教程" scheme="https://maple-meo.github.io/categories/%E4%B8%80%E4%BA%9B%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Git" scheme="https://maple-meo.github.io/tags/Git/"/>
    
    <category term="基础技能" scheme="https://maple-meo.github.io/tags/%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>FUSEE: A Fully Memory-Disaggregated Key-Value Store 论文阅读笔记</title>
    <link href="https://maple-meo.github.io/posts/4a17b1520/"/>
    <id>https://maple-meo.github.io/posts/4a17b1520/</id>
    <published>2023-05-06T13:30:07.643Z</published>
    <updated>2023-05-07T06:59:21.149Z</updated>
    
    <content type="html"><![CDATA[<h1 id="fusee-a-fully-memory-disaggregated-key-value-store阅读笔记"><a class="markdownIt-Anchor" href="#fusee-a-fully-memory-disaggregated-key-value-store阅读笔记"></a> FUSEE: A Fully Memory-Disaggregated Key-Value Store阅读笔记</h1><p>今天给大家带来的是今年fast23的一篇paper，<strong>FUSEE: A Fully Memory-Disaggregated Key-Value Store</strong>，一种完全解耦的<strong>K-V</strong>存储架构。</p><h2 id="background"><a class="markdownIt-Anchor" href="#background"></a> Background</h2><h3 id="in-memory-key-value-stores"><a class="markdownIt-Anchor" href="#in-memory-key-value-stores"></a> <strong>In-Memory Key-Value Stores</strong></h3><p>现在有很多著名的K-V Store，著名的例如redis，还有亚马逊的clashcache等等，传统的K-Vstore的工作模式，是用户从客户端发送网络请求到单体的存储服务器上，由服务器上的CPU进行K-V操作（insert、search、delete、update）来实现对K-V pair的使用。</p><p>但是由于传统K-V store中，采用了单体服务器的这样一个模式，导致cpu和内存资源都被耦合刀了一台机器上，这样会导致<strong>计算和存储资源利用率低下</strong>（<strong>Resource efficiency</strong> ），并且整个架构的<strong>弹性</strong>（<strong>Elasticity</strong>）很差。</p><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305062126191.png" style="zoom: 67%;" /><h3 id="disaggregated-memory"><a class="markdownIt-Anchor" href="#disaggregated-memory"></a> <strong>Disaggregated Memory</strong></h3><p>为了解决这个问题，后面的研究人员提出了一种解耦架构。具体来说，就是把原有在一台机器上的计算资源和存储资源分开并且集中，分为计算池和存储池。</p><p><strong>计算池</strong>主要负责计算，拥有较强的计算能力和较弱的存储能力，存储能力主要服务于缓存，计算池在client端</p><p><strong>存储池</strong>主要负责存储K-Vpair，拥有较弱的计算能力和较强的存储能力，计算能力主要服务于网络通信协议，存储池在Server端</p><p>两者通过一些新型的网络通信协议进行通信，使计算池能够直接对存储池进行操作。</p><p>这样的好处：</p><p>1.对于计算方面：计算资源能够统一调度共享。</p><p>2.对于存储方面：存储碎片化会减弱。</p><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305071459849.png" alt="image-20230507145908796" style="zoom:50%;" /><h3 id="existing-semi-disaggregated-key-value-stores"><a class="markdownIt-Anchor" href="#existing-semi-disaggregated-key-value-stores"></a> <strong>Existing Semi-Disaggregated Key-Value Stores</strong></h3><p>但是在K-V store中实现解耦架构使相对困难的，因为存储池的计算能力太弱，无法胜任元数据管理的工作。所以研究人员提出了一种半解耦架构，引入了一种单体服务器—元数据服务器（matadataServer）来单独完成对元数据进行管理任务，计算池依旧承担计算任务，存储池承担存储任务。</p><h4 id="serch操作"><a class="markdownIt-Anchor" href="#serch操作"></a> Serch操作</h4><p>当进行Search操作时，主要有以下两步操作：</p><p>Step1：Client首先通过RPC对元数据服务器发起请求，获取所需要查询的K-V pair所在的<strong>Mermroy Node</strong>（后称MN）地址（元数据）。</p><p>Step2：获取到MN地址后，使用RDMA直接去对应的存储K-V pair的MN上直接进行K-V操作（Read），得到所需要的K-Vpair的信息</p><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305071334027.png" alt="image-20230507133446981" style="zoom:50%;" /><h4 id="updata-insert-delete操作"><a class="markdownIt-Anchor" href="#updata-insert-delete操作"></a> UPDATA INSERT DELETE操作</h4><p>当进行UPDATA INSERT DELETE操作时，则需要多一步操作：</p><p>Step1：Client首先通过RPC对元数据服务器发起请求，获取所需要查询的K-V pair所在的MN的元数据</p><p>Step2：获取到MN地址后，使用RDMA直接去对应的存储K-V pair的MN上直接进行K-V操作（UPDATA INSERT DELETE），修改所需要的K-Vpair的信息</p><p>Step3：Clinet再向MatadataServer发起请求，将修改后的K-Vpair的元数据进行更新</p><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305071350617.png" alt="image-20230507135008573" style="zoom:50%;" /><h2 id="problem"><a class="markdownIt-Anchor" href="#problem"></a> Problem</h2><p>可以发现一个现象，就是所有的client在进行操作时，都需要访问元数据服务器，这对元数据服务器的性能存在很大的要求。这也是这篇paper主要想解决的问题：<strong>目前的半解耦模式因为元数据管理依旧依赖单体服务器，使的系统的性能没有被完全解放，依旧收到单体服务器（MatadataServer）限制</strong>。通过实验，元数据服务器至少要6个cpu核心，才能使其不成为资源调度瓶颈。</p><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305071350794.png" alt="image-20230507135023760" style="zoom:50%;" /><h2 id="motivationkey-idea"><a class="markdownIt-Anchor" href="#motivationkey-idea"></a> <strong>Motivation&amp;Key Idea</strong></h2><p>自然而然引出这篇paper的motivation：<strong>是否能够通过移除MatadataServer去实现一个完全解耦的架构</strong>。如下图所示的话，就是将架构从左边变为右边，移除了元数据服务器。</p><p>Key Idea：将元数据管理的任务交给计算池和存储池</p><p><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305071352987.png" alt="image-20230507135254941" /></p><h2 id="challenge"><a class="markdownIt-Anchor" href="#challenge"></a> Challenge</h2><h3 id="challeng-1client-centric-index-replication"><a class="markdownIt-Anchor" href="#challeng-1client-centric-index-replication"></a> challeng 1：Client-Centric Index Replication</h3><p>第一个挑战是以客户端为中心的索引赋值，在分布式系统中，需要把由不同客户端存储的index复制到其他server端（这是因为如果存在单一Server上，如果这个Server崩溃了，整个系统就G了），为了保证数据的一致性，目前的单体服务器之间是用过复制协议（Replocation Protocal）来完成的。</p><p>而这种方式在解耦架构的K-V store却无法使用，因为存储池的计算能力太弱了，无法运行复制协议。这样就无法保证数据的一致性。</p><p><strong>challeng1总结：MN的计算能力太弱，无法运行复制协议，导致数据一致性无法保证</strong></p><p><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305071356173.png" alt="image-20230507135610118" /></p><h3 id="challenge-2-remote-memory-allocation"><a class="markdownIt-Anchor" href="#challenge-2-remote-memory-allocation"></a> Challenge 2: Remote Memory Allocation</h3><p>第二个挑战是远程内存分配，即如何进行比较好的内存管理计算。</p><p>在完全解耦模式下，有两种设想的可能性，第一种是以客户端为中心的方法，另一种是以服务器为中心的方法。</p><p>以客户端为中心的方法：是以存储节点来存储元数据，然后客户端通过远程操作协议直接计算，然后对元数据直接进行修改，但因为此时内存上是全部客户端的元数据，这样操作会造成很大的同步开销。</p><p>以服务端为中心的方法：指的是直接由存储阶段来对元数据进行计算管理，但因为元数据管理的计算量对于存储节点计算能力来说太大，所以很容因为client带来的请求，导致跟不上请求的速度。</p><p><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305071357754.png" alt="image-20230507135726706" /></p><p><strong>challenge2总结：MN的计算能力太弱，无法承担细粒度的内存管理任务</strong></p><h3 id="challenge-3-metadata-corruption"><a class="markdownIt-Anchor" href="#challenge-3-metadata-corruption"></a> Challenge 3: Metadata Corruption</h3><p>第三个挑战是，元数据损坏问题</p><p>因为在整个分布式环境中，节点之间是非常不稳定的，客户端随时都有崩溃的风险。在传统的单体服务器架构中，如果其中一个Client崩溃了，由于存在元数据服务器或者单体服务器本身CPU的管理，不会对元数据进行污染。其他正常Client读到也是正常数据。</p><p>但是如果是在完全解耦的场景下，Client崩溃会导致部分元数据的修改已经整合到内存节点的元数据中，会导致其他正常的Client读到错误的数据。例如，当一个Client在对一个K-V pair进行UPDATE操作中途崩溃了，此时别的Client2读取的就是错误的K-V pair</p><p><strong>Challenge3总结：完全解构架构下，Client崩溃会影响到整个系统</strong></p><p><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305071403029.png" alt="image-20230507140315972" /></p><h2 id="fusee-overview"><a class="markdownIt-Anchor" href="#fusee-overview"></a> FUSEE Overview</h2><p><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305071404842.png" alt="image-20230507140412766" /></p><p>接下来我们看一下FUSEE的Overview，可以看到整个FUSEE架构还是又2计算池和存储池两大部分组成，其中这个Master负责初始化工作，不参与其他工作</p><p>FUSEE提出了三个设计</p><p>第一个是快照协议解决服务端中心index复制问题</p><p>第二个是两级内存管理机制，解决远程内存管理问题</p><p>第三个是嵌入式操作日志，解决元数据损坏问题</p><h2 id="design"><a class="markdownIt-Anchor" href="#design"></a> Design</h2><h3 id="design1the-snapshot-protocol"><a class="markdownIt-Anchor" href="#design1the-snapshot-protocol"></a> Design1：The SNAPSHOT protocol</h3><p>首先是第一个设计,快照协议.回到我们的第一个挑战，因为在内存结点中无法进行通过复制协议保证数据一致性。比如这个图，可能不同的客户端可能对不同节点同时进行读写操作。</p><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305071406468.png" alt="image-20230507140629435" style="zoom: 67%;" /><p>而保证数据一致性主要有以下两个关键问题：</p><p><strong>第一个是如何保证读用户不能够读到不完整的数据（Read）</strong></p><p><strong>第二个是如何有效的保证写用户之间造成的冲突（Write）</strong></p><h4 id="key-problem-1read"><a class="markdownIt-Anchor" href="#key-problem-1read"></a> Key-problem 1：Read</h4><p>针对第一个关键问题，为了防止单一节点崩溃导致不可用，Memery pool将索引分成了一个主要副本（Primary Slot）和多个备份副本（Backup Slot），读用户永远只读主副本的元数据作为结果，因为主副本有且仅有一份，保证所有读用户读到的都是一样的数据。</p><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305071409631.png" alt="image-20230507140914601" style="zoom:50%;" /><h4 id="key-problem-2write"><a class="markdownIt-Anchor" href="#key-problem-2write"></a> Key-problem 2：Write</h4><p>正对第二个关键问题，即不同用户同时写入不同的值，本文提出了最后写者胜（last-writer-wins）的方法，怎么去理解这个方法呢，看这个图，Memery pool已经完成了复制，有主要副本和多个备份副本。此时有两个Client相对A这个K-V pair进行修改，Client1想修改为B，Client2想修改为C。</p><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305071411090.png" alt="image-20230507141125060" style="zoom:50%;" /><p>第一步，两个Client都会与主要副本进行通信，获取期望值（Expected）：A，然后对所有的备份副本进行通信，若此时备份副本插槽值和期望值（Expected）：A相同，说明这个备份副本未被修改，进行抢夺修改，若和A不同，则说明此时这个备份副本已被别的Client修改，就通信下一个备份副本。（相当于就是两个Client抢备份副本）</p><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305071420553.png" alt="image-20230507142031516" style="zoom:50%;" /><p>第二步，当两个Client通信完所有备份副本后，比较备份副本插槽的序列</p><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305071421728.png" alt="image-20230507142147693" style="zoom:50%;" /><p>第三步，使用以下规则确定最后的胜者</p><p>1.成功修改完所有的备份副本的Client为胜者</p><p>2.成果修改完大部分的备份副本的Client为胜者</p><p>3.若没有修改完大部分的备份副本的Client，则值最小的Client为胜者</p><p>以这个例子为例，备份副本插槽的序列为BBC，Client1为修改完大部分的备份副本的Client，成为胜者，将主要副本的插槽修改为B。</p><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305071424619.png" alt="image-20230507142424580" style="zoom:50%;" /><h3 id="design2two-level-memory-management"><a class="markdownIt-Anchor" href="#design2two-level-memory-management"></a> Design2：Two-Level Memory Management</h3><p>这个设计的key idea <strong>是将整个元数据管理计算任务拆分成简单计算任务和复杂计算任务两部分</strong></p><p>当有一个请求过来时，将2GB空间分成块，内存结点将块分给Client，再有Client细致对这块内存进行管理。</p><p>具体来说：当Client A发起需要内存管理的请求（INSERT）时，MN首先选择一块数据块Block A，Block的大小一般为4KB、8KB、16KB，将其分配给发起请求的Client A，并添加一个index （Block A，Client A），明确Block A由Client A管理。然后Client A对Block A进行操作，在里面选择最适宜大小的位置，插入K-v pair。然后管理Block A里面的元数据。</p><p><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305071425397.png" alt="image-20230507142514352" /></p><p>这样MN承担管理大块的工作（计算量小），Clent承担小块的具体内存管理的工作（计算量小），此方法的同步开销也比较低，因为各Clent管理的不是全局的内存，而是分配给他的小块内存。</p><h3 id="design-3embedded-operation-log"><a class="markdownIt-Anchor" href="#design-3embedded-operation-log"></a> Design 3：Embedded Operation Log</h3><p>这个设计的Key idea是：<strong>将日志信息嵌入到K-v pair中，减少传输开销。</strong></p><p>元数据恢复一般通过日志来完成的，每完成一个操作，就在日志信息里面加一条。</p><p>日志序列必须和K-V pair的操作序列一致，所以单独发送日志信息，会需要额外的开销。</p><p>本文的主要思路是将日志和K-Vdata 一起打包传送，分配前就使用指针将logEntry按顺序串联起来（是一个双双向链表的数据结构），然后因为K-V pair是按顺序进行分配的，所以logEntry也具有了序列化。</p><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305071439176.png" alt="image-20230507143941125" style="zoom: 50%;" /><p>ps：这部分理解的不是很懂，大家可以看看原文，了解细节。。。TAT</p><h2 id="evaluation只给了重点实验哈更多请见paper"><a class="markdownIt-Anchor" href="#evaluation只给了重点实验哈更多请见paper"></a> Evaluation（只给了重点实验哈，更多请见paper）</h2><h3 id="platform"><a class="markdownIt-Anchor" href="#platform"></a> Platform</h3><p>数据集分为两类：</p><p>第一类YSCB：就是混合数据集，各个操作（SEARCH UPDATA INSERT DELETE操作）的占比不同，其中</p><p>YSCB-A为写密集数据集</p><p>YSCB-C为读密集数据集</p><p>第二类Microbenchmark ：单一操作数据集，EARCH UPDATA INSERT DELETE</p><p>对照方法：</p><p>1.Clover：最新的半解耦K-V store架构，就是有元数据服务器哒（见background）</p><p>2.pDPM-Direct：以客户端为中心的远程内存管理，具有很大同步开销哒（见Challenge）</p><p><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305071441921.png" alt="image-20230507144100871" /></p><h3 id="latencythroughput"><a class="markdownIt-Anchor" href="#latencythroughput"></a> Latency&amp;Throughput</h3><p><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305071446722.png" alt="image-20230507144650655" /></p><p>**Latency：**FUSE在INSERT和UPDATE上的表现最好，因为SNAPSHOT复制协议有限制的RTT。FUSE的SEARCH延迟略高于Clover，因为FUSE在单个RTT中读取哈希索引和KV对，这比仅在Clover中读取KV对慢。FUSE的DELETE延迟略高于pDPM Direct，因为FUSE在单个RTT中写入日志条目并读取哈希索引，这比仅在pDPM Direct中读取哈希索引要慢。</p><p>**Throughput：**pDPM Direct的吞吐量受到其远程锁的限制，随着客户端数量的增长，远程锁会导致大量的锁争用。对于Clover来说，尽管它消耗了更多的硬件资源，即8个额外的CPU内核和一个RNIC，但可扩展性仍然低于FUSE。这是因为元数据服务器的CPU处理能力限制了其吞吐量。相反，FUSE通过消除元数据服务器的计算瓶颈并有效解决与SNAPSHOT复制协议的冲突，提高了整体吞吐量。</p><p>主要是体现设计的总体效果。</p><h3 id="ycsb-throughput-two-level-memory-allocation-performance"><a class="markdownIt-Anchor" href="#ycsb-throughput-two-level-memory-allocation-performance"></a> YCSB-Throughput &amp; Two-level memory allocation performance</h3><p><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305071449782.png" alt="image-20230507144918720" /></p><p>**YCSB-Throughput：**当使用128个客户端将MN的数量从2个改变到5个时，具有写密集型工作负载（YCSB-a）和读密集型工作负荷（YCSB-C）的三种方法的吞吐量。pDPM Direct和Clover的吞吐量并没有增加，因为它们分别受到锁争用和元数据服务器有限计算能力的限制。对于FUSE，吞吐量随着内存节点数量从2个增加到3个而提高。由于总吞吐量受到计算节点数量的限制，因此没有进一步的吞吐量改进。</p><p>**Two-level memory allocation performance：**为了显示两级内存分配方案的有效性，我们将FUSE与以MN为中心的内存分配方案进行了比较，如图所示。由于MN上的计算能力有限，YCSB-A吞吐量下降了90.9%，而YCSB-C吞吐量保持不变，因为只读设置中不涉及内存分配。</p><p>主要是体现第二个设计的作用</p><h3 id="recover-from-crashed-clients"><a class="markdownIt-Anchor" href="#recover-from-crashed-clients"></a> Recover from Crashed Clients</h3><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305071451727.png" alt="image-20230507145102694" style="zoom:50%;" /><p>**Recover from Crashed Clients：**为了评估客户端从故障中恢复的效率，在更新1000次后崩溃并恢复客户端。FUSE从客户端故障中恢复需要177毫秒。内存注册和连接重新建立占总恢复时间的92%。日志遍历和KV请求恢复只占恢复时间的4%，这意味着日志遍历的开销是可以承受的。（第三个设计总体不是很明白orz）</p><h2 id="conclusion"><a class="markdownIt-Anchor" href="#conclusion"></a> <strong>Conclusion</strong></h2><p>最后是一个我自己对这篇paper的总结，我感觉这篇paper还是蛮interesting的</p><p><img src="https://maplemeo-1302524148.cos.ap-chengdu.myqcloud.com/image/202305071455296.png" alt="image-20230507145539212" /></p>]]></content>
    
    
    <summary type="html">今年Fast23的新paper哦！</summary>
    
    
    
    <category term="论文阅读笔记" scheme="https://maple-meo.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Storage" scheme="https://maple-meo.github.io/tags/Storage/"/>
    
    <category term="FAST" scheme="https://maple-meo.github.io/tags/FAST/"/>
    
    <category term="K-V Store" scheme="https://maple-meo.github.io/tags/K-V-Store/"/>
    
  </entry>
  
</feed>
