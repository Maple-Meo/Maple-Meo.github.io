{"meta":{"title":"Maplemeo","subtitle":"","description":null,"author":"Maplemeo","url":"https://Maple-Meo.github.io","root":"/"},"pages":[{"title":"","date":"2023-05-05T22:19:43.668Z","updated":"2023-05-05T22:19:43.668Z","comments":true,"path":"manifest.json","permalink":"https://maple-meo.github.io/manifest.json","excerpt":"","text":"{\"name\":\"Ariasakaの小窝\",\"short_name\":\"Ariasakaの小窝\",\"theme_color\":\"var(--lyx-theme)\",\"background_color\":\"var(--lyx-theme)\",\"display\":\"standalone\",\"scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"/img/16.png\",\"sizes\":\"16x16\",\"type\":\"image/png\"},{\"src\":\"/img/36.png\",\"sizes\":\"36x36\",\"type\":\"image/png\"},{\"src\":\"/img/48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\"},{\"src\":\"/img/72.png\",\"sizes\":\"72x72\",\"type\":\"image/png\"},{\"src\":\"/img/96.png\",\"sizes\":\"96x96\",\"type\":\"image/png\"},{\"src\":\"/img/144.png\",\"sizes\":\"144x144\",\"type\":\"image/png\"},{\"src\":\"/img/180.png\",\"sizes\":\"180X180\",\"type\":\"image/png\"},{\"src\":\"/img/apple-touch-icon.png\",\"sizes\":\"180x180\",\"type\":\"image/png\"},{\"src\":\"/img/192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"},{\"src\":\"/img/256.png\",\"sizes\":\"256x256\",\"type\":\"image/png\"},{\"src\":\"/img/512.png\",\"sizes\":\"512x512\",\"type\":\"image/png\"}],\"splash_pages\":null}"},{"title":"","date":"2023-05-05T22:11:24.766Z","updated":"2023-05-05T22:11:24.766Z","comments":true,"path":"package.json","permalink":"https://maple-meo.github.io/package.json","excerpt":"","text":"{\"name\":\"ariasakablog\",\"version\":\"1.0.17\",\"description\":\"SpeedUp!\",\"main\":\"index.js\",\"scripts\":{\"test\":\"echo \\\"Error: no test specified\\\" && exit 1\"},\"author\":\"\",\"license\":\"ISC\"}"},{"title":"关于","date":"2021-03-30T07:57:51.000Z","updated":"2023-05-05T20:44:44.182Z","comments":true,"path":"about/index.html","permalink":"https://maple-meo.github.io/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-07-03T12:48:08.000Z","updated":"2023-05-05T20:44:44.183Z","comments":true,"path":"categories/index.html","permalink":"https://maple-meo.github.io/categories/index.html","excerpt":"","text":""},{"title":"bangumis","date":"2022-07-16T02:35:32.000Z","updated":"2023-05-05T20:44:44.183Z","comments":true,"path":"bangumis/index.html","permalink":"https://maple-meo.github.io/bangumis/index.html","excerpt":"","text":""},{"title":"朋友圈","date":"2022-01-29T07:23:17.000Z","updated":"2023-05-05T20:44:44.184Z","comments":true,"path":"fcircle/index.html","permalink":"https://maple-meo.github.io/fcircle/index.html","excerpt":"","text":"🎣 钓鱼 与主机通讯中…… var fdataUser = { apiurl: '' }"},{"title":"小空调","date":"2022-11-24T23:37:35.000Z","updated":"2023-05-05T20:44:44.216Z","comments":true,"path":"kongtiao/index.html","permalink":"https://maple-meo.github.io/kongtiao/index.html","excerpt":"","text":""},{"title":"声明","date":"2022-07-10T03:13:49.000Z","updated":"2023-05-05T20:44:44.216Z","comments":true,"path":"license/index.html","permalink":"https://maple-meo.github.io/license/index.html","excerpt":"","text":"Copyright© LYX 2022 声明 | 版权协议 为了保持文章质量，并保持互联网的开放共享精神，保持页面流量的稳定，综合考虑下本站的所有原创文章均采用cc协议中比较严格的创作共用-非商业性-禁止演绎 4.0 国际标准。这篇文章主要想能够更加清楚明白的介绍本站的协议标准和要求。方便您合理的使用本站的文章。 本站无广告嵌入和商业行为。违反协议的行为不仅会损害原作者的创作热情，而且会影响整个版权环境。强烈呼吁您能够在转载时遵守协议。遵守协议的行为几乎不会对您的目标产生负面影响，鼓励创作环境是每个创作者的期望。 博客的分类介绍 经验分享包含原创内容，原创内容的非商用转载必须为完整转载且标注出处的带有超链接功能的完整url链接（需能点击）或访问原文之类字样的超链接。 转载内容为转载内容，均标注了出处。建议使用原链接打开，尊重原作者。所有转载内容尽可能为完整转载（如果有部分内容有问题可能会由部分删减和补充）并进行样式调整以适合本博客。如果转载该部分内容需要联系原作者。 你可以做什么？ 只要您遵守本页的许可，您可以自由地共享文章的内容 — 在任何媒介以任何形式复制、发行本作品。并且无需通知作者。 你需要遵守什么样的许可？ 署名 您必须标注内容的来源，您需要在文章开头部分（或者明显位置）标注原文章链接（建议使用超链接提升阅读体验）。 禁止商用 本站内容免费向互联网所有用户提供，分享本站文章时禁止商业性使用、禁止在转载页面中插入广告（例如谷歌广告、百度广告）、禁止阅读的拦截行为（例如关注公众号、下载App后观看文章）。 禁止演绎 分享全部内容（无修改） 您需要在文章开头部分（或者明显位置）标注原文章链接（建议使用超链接） 分享部分截取内容或者衍生创作 目前本站全部原创文章的衍生品禁止公开分享和分发。如有更好的修改建议，可以在对应文章下留言。如有衍生创作需求，可以在评论中联系。 什么内容会被版权保护 包括但不限于： 文章封面图片 文章标题和正文 站点图片素材（不含主题自带素材） 例外情况 本着友好互相进步的原则，被本站友链收录的博客允许博客文章内容的衍生品的分享和分发，但仍需标注出处。 本着互联网开放精神，您可以在博客文章下方留言要求授权博文的衍生品的分享和分发，标注您的网站地址。 作者原创代码及网站源代码协议 网站所有代码采用MIT协议，如有不同，作者会进行标注 随便扒站吧！ 网站本身有关 本站已开启存储桶全站加速，接入了灵天盾CDN，请刷流量的耗子尾汁！！！"},{"title":"友链","date":"2022-07-03T12:40:57.000Z","updated":"2023-05-05T22:19:43.668Z","comments":true,"path":"links/index.html","permalink":"https://maple-meo.github.io/links/index.html","excerpt":"","text":"🎣 钓鱼 冰糖红茶 “冰糖红茶”博客魔改组织的大佬们 小冰【冰】 做个有梦想的人！ Akilar【糖】 期待您的光临！ 张洪Heo【红】 分享设计与科技生活 贰猹【茶】 用这生命中的每一秒，给自己一个不后悔的未来 我的信息Butterfly & MengDfluidvolantishtml12345- name: Ariasakaの小窝 link: https://yisous.xyz avatar: https://bu.dusays.com/2022/12/15/639a9ebbbc1ad.jpg descr: 人有悲欢离合 月有阴晴圆缺 siteshot: https://vercel.yisous.xyz/img/siteshot.png123456- &#123; title: &#x27;Ariasakaの小窝&#x27;, intro: &#x27;人有悲欢离合 月有阴晴圆缺&#x27;, link: &#x27;https://yisous.xyz/&#x27;, image: &#x27;https://bu.dusays.com/2022/12/15/639a9ebbbc1ad.jpg&#x27;&#125;123456- title: Ariasakaの小窝 avatar: https://bu.dusays.com/2022/12/15/639a9ebbbc1ad.jpg url: https://yisous.xyz/ screenshot: https://yisous.xyz/img/siteshot.png keywords: 个人博客 description: 人有悲欢离合 月有阴晴圆缺1&lt;a href=&quot;https://yisous.xyz&quot;&gt;&lt;img src=&quot;https://bu.dusays.com/2022/12/15/639a9ebbbc1ad.jpg&quot; alt=&quot;avatar&quot;&gt;Ariasakaの小窝&lt;/a&gt; 推荐标签衡量标准1.网站没有不良内容 2.文章质量较高 3.文章较多/或者质量过硬 如何申请友链？ 点下面的按钮！ 快速添加友链"},{"title":"好听的音乐","date":"2022-07-14T08:37:40.000Z","updated":"2023-05-05T20:44:44.217Z","comments":true,"path":"musics/index.html","permalink":"https://maple-meo.github.io/musics/index.html","excerpt":"","text":"好听的歌 歌曲排行榜 博主会每隔一段时间将自己近期爱听的歌排行在下面 2022-7 咕咕咕…"},{"title":"fontawesome对照","date":"2022-11-25T00:16:09.000Z","updated":"2023-05-05T20:44:44.184Z","comments":true,"path":"fontawesome/index.html","permalink":"https://maple-meo.github.io/fontawesome/index.html","excerpt":"","text":"window.parent.postMessage(object,'*'); document.getElementById('ifm').scroll(0,document.getElementById('ifm').document.body.scrollHeight);"},{"title":"","date":"2023-05-06T10:06:53.369Z","updated":"2023-05-06T10:06:53.369Z","comments":true,"path":"messageboard/index.html","permalink":"https://maple-meo.github.io/messageboard/index.html","excerpt":"","text":"说说你的建议吧... 你也可以私发我的邮件913439694@qq.com寻求帮助或者提供建议。 隐藏/显示弹幕（缓解卡顿） document.title = '留言板 | maplemeoの小窝';"},{"title":"敲木鱼","date":"2022-11-25T00:16:09.000Z","updated":"2023-05-05T20:44:44.218Z","comments":true,"path":"muyu/index.html","permalink":"https://maple-meo.github.io/muyu/index.html","excerpt":"","text":"功德：0 功德+100 .muyu-layout { background: black; display: flex; width: 100%; border-radius: 20px; position: relative; justify-content: center; height: 90vh; align-items: center; } #muyu-box img { width: 250px; } #jishu-box{ top: 55px; position: absolute; } #muyu-box p { color: white; opacity: 0; font-size: 25px; } #jishu-box p { color: white; font-size: 30px; } var gongde = document.getElementById(\"gongde\"); var muyu = document.getElementById(\"muyu\"); var jishu = document.getElementById(\"jishu-box\"); var mp3Url = \"/music/muyu.mp3\"; var player = new Audio(mp3Url); var num = 0; muyu.addEventListener(\"click\", function () { num+=100; player.load(); player.play(); muyu.animate([{ transform: 'scale(0.85)' }, { transform: 'scale(1.03)' }, { transform: 'scale(1)' }], 500); gongde.animate([{ opacity: 0, transform: 'translateY(0)' },{ opacity: 0.3, transform: 'translateY(-10px)' },{ opacity: 0.8, transform: 'translateY(-20px)' }, { opacity: 1, transform: 'translateY(-30px)' }, { opacity: 0.8, transform: 'translateY(-35px)' }, { opacity: 0, transform: 'translateY(-40px)' }], 600); jishu.innerHTML = \"功德：\"+num+\"\"; });"},{"title":"分站","date":"2022-08-04T03:38:05.000Z","updated":"2023-05-05T22:19:43.667Z","comments":true,"path":"othersite/index.html","permalink":"https://maple-meo.github.io/othersite/index.html","excerpt":"","text":"一些博主搭建的其它的站点： PS：划掉的表示已挂 域名 用处 搭建原因 yisous.xyz 博客，也是主站（默认无www） 分享一些东西 oj.yisous.xyz OnlineJudge系统 用于自己练习信奥赛题目其实是搞来象征意义的 status.yisous.xyz 网站状态监控 用于监控网站的状态，基于uptimeRobot mc.yisous.xyz Minecraft服务器 用来联机玩，类似于粉丝服那种，还没弄好 tc.yisous.xyz Typecho测试站 看看typecho怎么样，搞来玩的，已经由Wordpress迁移至当前的Typecho，未来服务器文档之后可能会换用 yisous.tk/lyxop.xyz 短链接生成器 制作短链接，使用本站域名，技术有限，所以很丑 bbs.yisous.xyz LYXの论坛 交流一些事情，也可以闲聊，还没弄说是交流其实还是搞来象征意义搞来玩的 博主的一些域名 域名 用处 yisous.xyz 主要使用的域名，当时看到dynadot14块一年就买了，这个名字就是念起来顺口 lyxop.xyz 注册拿来给副站用的，使用blog.lyxop.xyz进入主站。由于域名续费太贵，所以打算以后换成yisous.tk，其余一样 ariasaka.top 在硅云白嫖的一个域名，后续可能会作为主域名使用 lyxoff2233.eu.org 以前的eu.org域名，还不错，后面要拿来想办法用一用 lyxofficial.eu.org 图一乐域名 yisous.tk 20年为了搭树莓派服搞的域名，可是树莓派没多久就被我超坏了，现在就买不起了，后来这个域名过期，现在又弄回来作为副站使用，使用blog.yisous.tk进入主站，www和根域名主站用于提供短域名服务（已挂）。 注意：本博客强制HTTPS，旧电脑可能会出现问题。 #article-container a:not(.post-meta__tags):not(img):not(a[data-fancybox]):hover{ border-radius: 6px; background-color: #425aef; text-decoration: none!important; color:#fff!important; border:none; box-shadow: #dadada 0 0 8px 2px; } #article-container a:not(.post-meta__tags):not(.headerlink):not(a[data-fancybox]){ /* padding:0 2px; */ /* text-decoration: 1px solid #425aef; */ /* text-decoration: underline; */ border-bottom: 2px solid #425aef; color:var(--font-color); padding:4px }"},{"title":"说说","date":"2023-05-06T09:13:39.698Z","updated":"2023-05-06T09:13:39.698Z","comments":true,"path":"speaks/index.html","permalink":"https://maple-meo.github.io/speaks/index.html","excerpt":"","text":"function doSpeaks() { document.title = '说说 | Meoplemeoの小窝'; bbtalk.init({ appId: \"4VW4973kmk49SF3Uf95zei5n-MdYXbMMI\", appKey: \"WHwReevjdewgjrcJB4RKBQXL\", serverURLs: 'https://4vw4973k.api.lncldglobal.com', pageSize:1919810 }) } document.addEventListener('DOMContentLoaded', (e) => { doSpeaks(); }) document.addEventListener('pjax:complete', (e) => { doSpeaks(); })"},{"title":"标签","date":"2022-07-03T12:51:29.000Z","updated":"2023-05-05T20:44:44.220Z","comments":true,"path":"tags/index.html","permalink":"https://maple-meo.github.io/tags/index.html","excerpt":"","text":""},{"title":"网站更新日志","date":"2022-07-02T11:56:00.000Z","updated":"2023-05-05T22:19:43.667Z","comments":true,"path":"update/index.html","permalink":"https://maple-meo.github.io/update/index.html","excerpt":"","text":"Acryple v1.0.0 2022-10-23 经过了深思熟虑，博客主题独立啦！ 现在的主题叫做Acryple，具体见： 引用站外地址 博客正式独立主题啦！ Ariasakaの小窝 目前博客有： 更好的右键菜单 留言弹幕 博客设置（功能贼多大家自己看） 不错的UI，至今为止主css(style.css)有3k行 一些小功能比如公祭日弹窗自动欢迎等 大概就是这些了。 Acryple v1.0.110 2022-12-13 加入pwa 全站采用存储桶加速，可惜并没有卵用 很多资源转为了白嫖eleme 抛弃metingjs，目前aplayer的歌曲托管在eleme npm镜像中 友链添加随机头像 博客设置画饼的三个功能仍未修复 qwq 修复一些bug 大改swiper，参考自Leonus 完成Build101的大部分饼 修复了朋友圈爬取bug sw换回cyfan 套上了灵天盾亚太CDN 因为性能问题，移除了文章日历 给导航栏加上滚动动画（画饼） bb布局重构（画饼） 分类标签栏bug修复（画饼） 语雀云端写作（因bug已回滚） gulp（因bug已回滚） 文章进度显示（画饼） 修复pjax的bug 右键菜单功能完善 Acryple v1.0.101 2022-12-06 （PS：部分画大饼 壮举：适配pjax！！！ 修复黑幕的bug 修复评论弹幕dom错误，溢出的bug 弹幕换用swiper方案，并且优化样式 首页bb增加天数显示，以及换用swiper(预计) 修复一些bug（e.g.aplayer、博客设置 优化部分动画/样式 完善博客控制面板，仍有部分未完工 修复部分文章页面溢出的bug 悼念某人，banner换图 pace换用xlenco的胶囊方案 由于未知特性删除了pjax的加载动画，首次保留 部分资源换用缤纷云 换用空梦的sw 不断优化加载速度ing… 修复首页轮播bug(预计) 评论样式修改，预计添加用户tag功能 更换背景没有时效限制了 欢迎文本 左右栏切换 弹幕开关设置自动显隐 落樱特效 aplayer显隐功能 明暗模式自动切换、固定导航栏功能（预计） 边栏样式修改 修复点赞第一赞没反应的bug 修复ghactions部署没有npm缓存的bugtnnd我等十几分钟安装依赖等几个月了，结果是顺序反了 目前朋友圈后端出现了bug，导致不更新，请静待修复 Acryple v1.0.100 2022-12-04 修复部分bug（不，特性 优化部分动画/样式 修改右键菜单 重写博客设置，并将 rightside 的部分功能移动到博客设置中，灵感来源于ichika（未完工 支持隐藏 ASide 了 短暂变灰 修复公祭日js的bug 修复右键菜单在主页也能开启阅读模式的bug 优化手机端阅读体验，去卡片化 优化latex样式 修复部分分辨率下无导航栏的bug aplayer的体验更好了 优化部分样式，适配部分还未适配的黑暗模式 加了一个字体 重写分类和标签、归档页的样式，来源于ichika 优化页脚查看体验 优化网站性能 支持全屏 css 5k+ qpzc 解封辣！！！ 究极跳号？！CRT18:?! Acryple v1.0.92 修复部分bug（不，特性 优化部分样式 更改了博客设置的部分主题色 pages页面在Acrylic主题下的背景得到了改善 更改加载页面背景 重新进行部分断点 把博客api\\服务全部迁移到了另一个github账号~~(垃圾桶)~~上 优化搜索UI 对butterfly4.5.1进行了选择性同步(优化繁体字库) 疫情退退退awa Acryple v1.0.91 修复部分bug（不，特性 为APlayer进行完善 添加早报、木鱼、空调页面，参考Chuckle 更改关于页面，参考安知鱼的教程 尝试npm全站静态化，最终失败放弃qwq 优化sw，加载速度略有提升 新增文章统计 优化部分样式 Acryple v1.0.81 2022-11-23 修复部分bug（不，特性 优化性能问题，对弹幕进行了节流 添加APlayer，可惜没有pjax qwq 优化弹幕（更洪化了） 调整网站布局 修改一些样式 PS：在1.0.51偷偷加了一号字号你们发现没有(doge) Acryple v1.0.51 修复部分bug（不，特性 优化性能问题（但是好像还是没毛提升 换用Twikoo-magic表情包 为了OI添加 KaTeX\\textbf{ \\KaTeX} KATE​X 修复跳转链接因原有bug被迫使原页面刷新的bug Acryple v1.0.14 2022-11-10 修复部分bug（不，特性 优化性能问题（但是好像还是没毛提升 增加浏览器过期提醒以及banIE，参考chuckle以及b站 增加fps显示 评论表情添加颜文字 修复手机端侧边栏bug PS：作为一个萌新OIer依然没有考虑发oi文 ╮(╯▽╰)╭ 以前的更新日志哔哩哔哩 (゜-゜)つロ 干杯！ 2022 07-02 终于弄好网站了，庆祝一下🎉 Gitalk不知道为什么不显示出来… 07-03 小更新，修改细节 作者的Html实在太菜了，效果并不好 07-04 大更新 修改了很多ui 07-05 大更新 修改细节UI和友链部分，增加吐槽部分 07-06 小更新，做好一些功能并且写了第一篇文章 07-08 大更新，更改首页布局，增加首页分区 07-09 小更新，修改细节，适配手机端，修复bug，说说由Artitalk换为BBtalk 07-14 前面几天忘记写更新了，更新了很多UI和功能。。。 07-18 前面几天又忘记写更新了小小修改了一些布局，把鸽了很久的博客写完了并且还加了萌百的黑幕，没有你知道的太多了差评 07-22 前面几天又双忘记写更新了折腾了很多，加了自己的域名，把你知道的太多了弄出来了，并且修复了很多js的bug，把unpkg换成fastly.jsdelivr或者elemecdn，提升速度（竟然有人加了我友链，怎么知道这个网站的？） 08-12 前面几天又双叒忘记写更新了还是折腾了很多，按照冰糖红茶大佬们的方法加了不少东西，比如那个人潮汹涌模拟器（主页的）、文章点赞、无缝跳转等等，换成jsdelivr加速，同时也在最大化利用GoormIDE，不过在险些没有数据之后就尽可能迁移到了其它没有风险的平台。 08-25 最近在糖果屋群友们的建议和帮助下修改了很多功能,以后每隔一段时间都会写详细的日志而不是像前面简单概括了。 留言板的弹幕是真的像b站视频弹幕了，过一段时间修复了bug之后放教程 新增博客设置，做了一个极简风的主题，支持更换主题色，也可以换回之前的主题，可以禁用模糊效果和开启硬件加速提升性能 修复了部分排版bug，对safari进行了一些适应，感谢Apple Store和洪哥的帮助。 增加了hover的缩放效果，有层次感 优化动画 修复留言弹幕、右键菜单的bug并且把新版的代码更新到文章中 优化细节样式 新增最新文章标记 总算部署好朋友圈了！leancloud国内版垃圾！"},{"title":"工具","date":"2022-07-13T07:23:02.000Z","updated":"2023-05-05T20:44:44.221Z","comments":true,"path":"tools/index.html","permalink":"https://maple-meo.github.io/tools/index.html","excerpt":"","text":"镜像站常用的PyPi/npm/SDK镜像站 TUNA 清华大学开源镜像站 豆瓣PYPI源 豆瓣PYPI镜像站 jsDelivr jsDelivr静态资源加速（GFW已墙） unpkg 另一个静态资源加速CDN（没墙） 资源下载类好用的资源下载/收录站 MSDN,我告诉你 微软MSDNED2K镜像收录站 唧唧Down 下载B站视频 无损生活 免费下载全网绝大部分无损音乐 百度网盘简易下载助手 特别好用的bd网盘破解器（不知道为什么公众号分享很怕敏感词） 日常工具常用日常工具 计时器 闹钟网计时器 图片系列关于图片的工具 Bigjpg 高清修复图片与降噪 waifu2x 高清修复图片与降噪，性能貌似好一点 jpgrm 高清修复图片与降噪 Sheilds 制作Github项目徽章 极简壁纸 海量高清壁纸美图&二次元图片 常用测试网站测试一些基础功能 还没做完呢 你瞅啥？还妹做完呢！"},{"title":"早报","date":"2022-11-24T23:37:35.000Z","updated":"2023-05-05T20:44:44.222Z","comments":true,"path":"zaobao/index.html","permalink":"https://maple-meo.github.io/zaobao/index.html","excerpt":"","text":""}],"posts":[{"title":"如何实现一个简单的含有输入参数的Hello内核模块，并在其中实现单链表","slug":"如何实现一个含有输入参数的Hello+单链表的内核模块","date":"2023-05-10T11:41:06.065Z","updated":"2023-05-10T12:39:10.772Z","comments":true,"path":"posts/4a17b1554/","link":"","permalink":"https://maple-meo.github.io/posts/4a17b1554/","excerpt":"","text":"如何实现一个简单的含有输入参数的Hello内核模块，并在其中实现单链表 Linux内核模块编程 这篇文章的目的是使个人： 1.熟悉操作系统内核编程开发环境 2.初步掌握Linux环境下内核模块编写、编译、调试及运行的基本流程 3.熟悉内核编程的基本方法和步骤 编程环境 VMware Workstation Pro + Ubuntu 16.04 LTS VMware+Ubuntu 16.04 LTS虚拟机安装教程参考： 2021安装Vmware和Ubuntu教程(特详细) - 知乎 (zhihu.com) 其中Ubuntu 16.04 LTS镜像下载参考： (39条消息) ubuntu 16.04 镜像下载（国内开源镜像站）_ubtun16.04_dongjuexk的博客-CSDN博客 什么是内核模块？ 内核模块的全称是动态可加载内核模块(Loadable Kernel Modul,KLM)，可以动态载入内核，让它成为内核代码的一部分。一个模块一般由一组函数和数据结构组成。 模块要求 1.Ubuntu 16.04环境下实现含输入参数的Hello内核模块，可以按照输入的打印行数及姓名输出相应的信息。 2.在模块中实现单链表，完成insert、delete、lookup、print操作 如何编写带有输入参数的最简单的Hello World模块 打开终端，创建项目文件夹Linux-expr，命令如下： 123mkdir Linux-expr cd Linux-expr 创建hello.c文件，文件内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;linux/init.h&gt;#include&lt;linux/module.h&gt; //每个模块都要包括的头文件#include&lt;linux/kernel.h&gt; //使用到了printk()函数进行输出#include&lt;linux/moduleparam.h&gt; MODULE_LICENSE(&quot;GPL&quot;); //没有指定license会出现errorstatic char*whom = &quot;world&quot;; static int num = 1; //定义静态变量使变量只被当前文件访问//传递命令参数 S_IRUGO 指明参数可以被所有人读取 module_param(whom,charp,S_IRUGO);module_param(num,int,S_IRUGO);//作为驱动模块的加载函数，将相应的驱动模块hello_init加载到Linux内核中，相当于普通文件的c函数static int hello_init(void)&#123; int i; for (i=0;i&lt;num;i++)&#123; //只能使用内核里定义好的C函数，printk会根据日志级别将指定信息输出到控制台或日志文件中，KERN_ALERT会输出到控制台 printk(KERN_ALERT &quot;hello,%s\\n&quot;,whom); &#125; return 0;&#125;//将已存在的驱动模块hello_exit从内核中卸载static void hello_exit(void)&#123; printk(KERN_ALERT &quot;goodbye,kernel/n&quot;);&#125;//加载or卸载模块module_init(hello_init);module_exit(hello_exit);// 可选的一些属性 MODULE_AUTHOR(&quot;Maplemeo-silence&quot;);MODULE_DESCRIPTION(&quot;This is a simple example!/n&quot;);MODULE_VERSION(&quot;v1.0&quot;);MODULE_ALIAS(&quot;A simplest example&quot;); 创建makefile文件，内容如下： 1234567891011obj-m:=hello.oCURRENT_PATH :=$(shell pwd)VERSION_NUM :=$(shell uname -r)LINUX_PATH :=/usr/src/linux-headers-$(VERSION_NUM)all : make -C $(LINUX_PATH) M=$(CURRENT_PATH) modulesclean : make -C $(LINUX_PATH) M=$(CURRENT_PATH) clean 通过make命令，编译文件： 1make 可以看到目录下出现以下文件，其中hello.ko文件为我们所需要的内核模块文件： 使用insmod 命令加载模块（使用sudo权限） 1sudo insmod hello.ko 使用lsmod查看模块是否加载进去，可以看到hello已经可以看到 1sudo lsmod 使用demesg命令查看输出，可以看到有hello，world的输出 1sudo demesg 最后使用rmmod 命令卸载模块 1sudo rmmod hello 如何编在模块中实现单链表 内核模块中实现单链表和在普通c程序中相差不多，值得注意的是，内存分配还是malloc被kmalloc所替换 listnode结构体如下所示，就是最简单的单链表结构： 1234struct listnode&#123; int val_; //data struct listnode* next_; &#125;; hello.c文件改写为如下内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include&lt;linux/init.h&gt;#include&lt;linux/module.h&gt;#include&lt;linux/kernel.h&gt;#include&lt;linux/moduleparam.h&gt;#include &lt;linux/slab.h&gt;MODULE_LICENSE(&quot;GPL&quot;);static char*whom = &quot;world&quot;;static int num = 1;struct listnode&#123; int val_; struct listnode* next_;&#125;;//插入操作int insert(int val,struct listnode* head)&#123; if(head == NULL)&#123; printk(KERN_ALERT &quot;the head is null, can not insert\\n&quot;); return -1; &#125;else&#123; struct listnode* curr; curr = head; int num; num = 0; while(curr-&gt;next_!=NULL)&#123; curr = curr-&gt;next_; num++; &#125; struct listnode *new_node; new_node=kmalloc(sizeof(*new_node),GFP_KERNEL); new_node-&gt;val_ = val; new_node-&gt;next_ = NULL; curr-&gt;next_ = new_node; printk(KERN_ALERT &quot;insert success!!! the new %d val = %d\\n&quot;,num,new_node-&gt;val_); return 1; &#125;&#125;//打印操作void print(struct listnode* head)&#123; if(head == NULL)&#123; printk(KERN_ALERT &quot;the head is null, can not printf\\n&quot;); return; &#125; int num; num = 0; struct listnode* curr; curr = head; printk(KERN_ALERT &quot;---------List Print--------\\n&quot;); while(curr-&gt;next_!=NULL)&#123; curr = curr-&gt;next_; printk(KERN_ALERT &quot;the %d val = %d\\n&quot;,num,curr-&gt;val_); num++; &#125; printk(KERN_ALERT &quot;-------List Print end--------\\n&quot;); return;&#125;//删除操作void delete(int val,struct listnode* head)&#123; if(head == NULL)&#123; printk(KERN_ALERT &quot;the head is null, can not delete\\n&quot;); return; &#125; struct listnode* curr; curr = head; int num; num = 0; while(curr-&gt;next_ != NULL)&#123; struct listnode* prev; prev = curr; curr = curr-&gt;next_; if(curr-&gt;val_ == val)&#123; prev-&gt;next_ = curr-&gt;next_; kfree(curr); //使用kfree，而不是free printk(KERN_ALERT &quot;delete success!!! the delete %d val = %d\\n&quot;,num,val); return 1; &#125; num++; &#125; printk(KERN_ALERT &quot;delete fail!!! can not find val = %d\\n&quot;,val); return -1;&#125;//查找操作void lookup(int val,struct listnode* head)&#123; if(head == NULL)&#123; printk(KERN_ALERT &quot;the head is null, can not delete\\n&quot;); return; &#125; struct listnode* curr; curr = head; int num; num = 0; while(curr-&gt;next_ != NULL)&#123; curr = curr-&gt;next_; if(curr-&gt;val_ == val)&#123; printk(KERN_ALERT &quot;lookup success!!! the lookup %d val = %d\\n&quot;,num,curr-&gt;val_ ); return 1; &#125; num++; &#125; printk(KERN_ALERT &quot;lookup fail!!! can not lookup val = %d\\n&quot;,curr-&gt;val_); return -1;&#125;//传递命令参数 S_IRUGO 指明参数可以被所有人读取 module_param(whom,charp,S_IRUGO);module_param(num,int,S_IRUGO);//程序中必须有下列两个函数static int hello_init(void)&#123; int i; for (i=0;i&lt;num;i++)&#123; //使用的是printk 不是printf（其是C库函数） printk(KERN_ALERT &quot;hello,%s\\n&quot;,whom); &#125; //创建头节点 struct listnode *head; //使用的是kmalloc 不是malloc（其是C库函数） head=kmalloc(sizeof(*head),GFP_KERNEL); if(head != NULL)&#123; head-&gt;val_ = 0; head-&gt;next_ = NULL; printk(KERN_ALERT &quot;the head val: %d\\n&quot;,head-&gt;val_); &#125; //进行测试操作 print(head); //打印操作 insert(7,head); //插入操作 print(head); delete(2,head); //删除操作 print(head); insert(1,head); insert(5,head); print(head); delete(1,head); lookup(7,head); //查找操作 print(head); return 0;&#125;static void hello_exit(void)&#123; printk(KERN_ALERT &quot;goodbye,kernel/n&quot;);&#125;//加载or卸载模块module_init(hello_init);module_exit(hello_exit);// 可选 MODULE_AUTHOR(&quot;Maplemeo-silence&quot;);MODULE_DESCRIPTION(&quot;This is a simple example!/n&quot;);MODULE_VERSION(&quot;v1.0&quot;);MODULE_ALIAS(&quot;A simplest example&quot;); 使用make、insmod、demesg、 rmmod命令查看链表是否正常使用，至此整个内核模块实现完成。","categories":[{"name":"一些教程","slug":"一些教程","permalink":"https://maple-meo.github.io/categories/%E4%B8%80%E4%BA%9B%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://maple-meo.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"内存模块编程","slug":"内存模块编程","permalink":"https://maple-meo.github.io/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9D%97%E7%BC%96%E7%A8%8B/"}]},{"title":"Maplemeo Git 常用命令学习笔记","slug":"Maplemeo Git 常用命令学习笔记 63d0b3ab80244b808d14ea266d226dd8","date":"2023-05-07T04:31:58.681Z","updated":"2023-05-07T07:25:14.236Z","comments":true,"path":"posts/4a17b1551/","link":"","permalink":"https://maple-meo.github.io/posts/4a17b1551/","excerpt":"","text":"Maplemeo Git 常用命令学习笔记 学习参考视频： Git工作流和核心原理 | GitHub基本操作 | VS Code里使用Git和关联GitHub_哔哩哔哩_bilibili Git环境配置 查看配置信息 1git config -l 查看系统配置信息 1git config --system --list 查看全局配置信息 1git config --global --list 配置个人信息 12git config --global [user.name](http://user.name/) &quot;maplemeo&quot;git config --global user.email &quot;[913439694@qq.com](mailto:913439694@qq.com)&quot; 对目标文件夹进行初始化操作，告诉git此文件夹需要进行版本控制操作，初始化后，默认处于主分支（master） 1git init 创建一个测试文件 1echo &quot;版本一&quot; &gt; [lao.md](http://lao.md/) 查看当前状态 1git status 将lao.md文件添加到缓冲区，并查看状态 123git add lao.mdgit status 可以看到，提示可以进行commit提交 1git commit 此时会出现conmmit文件信息，可以在第一行添加”版本1“作为conmmit的说明 提交完成后，使用git status查看状态 添加一行内容到lao.md 将lao.md文件添加到缓冲区，并查看状态 1git add lao.md 使用-m参数可以直接添加信息，不进入COMMIT文件 1git commit -m &quot;版本二” 查看版本提交日志 1git log 创建忽略追踪分支文件 1touch .gitignore 在gitignore文件里面可以添加需要忽略追踪的文件名 创建新分支使用git branch 新分支名 1git branch oneuse 查看分支是否创建成功 1git branch 切换到新分支 1git checkout oneuse 回到master 1git checkout master 删除新分支 1git branch -d oneuse 如果新分支有修改，使用-d会出现提示，如果确定删除分支，建议使用-D删除分支 1git branch -D oneuse 创建新分支并直接跳转 1git checkout -b newuse 修改lao.md文件，并add和commit 将分支修改合并到master上面，可以看到master的lao.md文件已经修改 123git checkout mastergit merge newuse","categories":[{"name":"一些教程","slug":"一些教程","permalink":"https://maple-meo.github.io/categories/%E4%B8%80%E4%BA%9B%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://maple-meo.github.io/tags/Git/"},{"name":"基础技能","slug":"基础技能","permalink":"https://maple-meo.github.io/tags/%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/"}]},{"title":"FUSEE: A Fully Memory-Disaggregated Key-Value Store 论文阅读笔记","slug":"FUSEE-reading-group","date":"2023-05-06T13:30:07.643Z","updated":"2023-05-07T06:59:21.149Z","comments":true,"path":"posts/4a17b1520/","link":"","permalink":"https://maple-meo.github.io/posts/4a17b1520/","excerpt":"","text":"FUSEE: A Fully Memory-Disaggregated Key-Value Store阅读笔记 今天给大家带来的是今年fast23的一篇paper，FUSEE: A Fully Memory-Disaggregated Key-Value Store，一种完全解耦的K-V存储架构。 Background In-Memory Key-Value Stores 现在有很多著名的K-V Store，著名的例如redis，还有亚马逊的clashcache等等，传统的K-Vstore的工作模式，是用户从客户端发送网络请求到单体的存储服务器上，由服务器上的CPU进行K-V操作（insert、search、delete、update）来实现对K-V pair的使用。 但是由于传统K-V store中，采用了单体服务器的这样一个模式，导致cpu和内存资源都被耦合刀了一台机器上，这样会导致计算和存储资源利用率低下（Resource efficiency ），并且整个架构的弹性（Elasticity）很差。 Disaggregated Memory 为了解决这个问题，后面的研究人员提出了一种解耦架构。具体来说，就是把原有在一台机器上的计算资源和存储资源分开并且集中，分为计算池和存储池。 计算池主要负责计算，拥有较强的计算能力和较弱的存储能力，存储能力主要服务于缓存，计算池在client端 存储池主要负责存储K-Vpair，拥有较弱的计算能力和较强的存储能力，计算能力主要服务于网络通信协议，存储池在Server端 两者通过一些新型的网络通信协议进行通信，使计算池能够直接对存储池进行操作。 这样的好处： 1.对于计算方面：计算资源能够统一调度共享。 2.对于存储方面：存储碎片化会减弱。 Existing Semi-Disaggregated Key-Value Stores 但是在K-V store中实现解耦架构使相对困难的，因为存储池的计算能力太弱，无法胜任元数据管理的工作。所以研究人员提出了一种半解耦架构，引入了一种单体服务器—元数据服务器（matadataServer）来单独完成对元数据进行管理任务，计算池依旧承担计算任务，存储池承担存储任务。 Serch操作 当进行Search操作时，主要有以下两步操作： Step1：Client首先通过RPC对元数据服务器发起请求，获取所需要查询的K-V pair所在的Mermroy Node（后称MN）地址（元数据）。 Step2：获取到MN地址后，使用RDMA直接去对应的存储K-V pair的MN上直接进行K-V操作（Read），得到所需要的K-Vpair的信息 UPDATA INSERT DELETE操作 当进行UPDATA INSERT DELETE操作时，则需要多一步操作： Step1：Client首先通过RPC对元数据服务器发起请求，获取所需要查询的K-V pair所在的MN的元数据 Step2：获取到MN地址后，使用RDMA直接去对应的存储K-V pair的MN上直接进行K-V操作（UPDATA INSERT DELETE），修改所需要的K-Vpair的信息 Step3：Clinet再向MatadataServer发起请求，将修改后的K-Vpair的元数据进行更新 Problem 可以发现一个现象，就是所有的client在进行操作时，都需要访问元数据服务器，这对元数据服务器的性能存在很大的要求。这也是这篇paper主要想解决的问题：目前的半解耦模式因为元数据管理依旧依赖单体服务器，使的系统的性能没有被完全解放，依旧收到单体服务器（MatadataServer）限制。通过实验，元数据服务器至少要6个cpu核心，才能使其不成为资源调度瓶颈。 Motivation&amp;Key Idea 自然而然引出这篇paper的motivation：是否能够通过移除MatadataServer去实现一个完全解耦的架构。如下图所示的话，就是将架构从左边变为右边，移除了元数据服务器。 Key Idea：将元数据管理的任务交给计算池和存储池 Challenge challeng 1：Client-Centric Index Replication 第一个挑战是以客户端为中心的索引赋值，在分布式系统中，需要把由不同客户端存储的index复制到其他server端（这是因为如果存在单一Server上，如果这个Server崩溃了，整个系统就G了），为了保证数据的一致性，目前的单体服务器之间是用过复制协议（Replocation Protocal）来完成的。 而这种方式在解耦架构的K-V store却无法使用，因为存储池的计算能力太弱了，无法运行复制协议。这样就无法保证数据的一致性。 challeng1总结：MN的计算能力太弱，无法运行复制协议，导致数据一致性无法保证 Challenge 2: Remote Memory Allocation 第二个挑战是远程内存分配，即如何进行比较好的内存管理计算。 在完全解耦模式下，有两种设想的可能性，第一种是以客户端为中心的方法，另一种是以服务器为中心的方法。 以客户端为中心的方法：是以存储节点来存储元数据，然后客户端通过远程操作协议直接计算，然后对元数据直接进行修改，但因为此时内存上是全部客户端的元数据，这样操作会造成很大的同步开销。 以服务端为中心的方法：指的是直接由存储阶段来对元数据进行计算管理，但因为元数据管理的计算量对于存储节点计算能力来说太大，所以很容因为client带来的请求，导致跟不上请求的速度。 challenge2总结：MN的计算能力太弱，无法承担细粒度的内存管理任务 Challenge 3: Metadata Corruption 第三个挑战是，元数据损坏问题 因为在整个分布式环境中，节点之间是非常不稳定的，客户端随时都有崩溃的风险。在传统的单体服务器架构中，如果其中一个Client崩溃了，由于存在元数据服务器或者单体服务器本身CPU的管理，不会对元数据进行污染。其他正常Client读到也是正常数据。 但是如果是在完全解耦的场景下，Client崩溃会导致部分元数据的修改已经整合到内存节点的元数据中，会导致其他正常的Client读到错误的数据。例如，当一个Client在对一个K-V pair进行UPDATE操作中途崩溃了，此时别的Client2读取的就是错误的K-V pair Challenge3总结：完全解构架构下，Client崩溃会影响到整个系统 FUSEE Overview 接下来我们看一下FUSEE的Overview，可以看到整个FUSEE架构还是又2计算池和存储池两大部分组成，其中这个Master负责初始化工作，不参与其他工作 FUSEE提出了三个设计 第一个是快照协议解决服务端中心index复制问题 第二个是两级内存管理机制，解决远程内存管理问题 第三个是嵌入式操作日志，解决元数据损坏问题 Design Design1：The SNAPSHOT protocol 首先是第一个设计,快照协议.回到我们的第一个挑战，因为在内存结点中无法进行通过复制协议保证数据一致性。比如这个图，可能不同的客户端可能对不同节点同时进行读写操作。 而保证数据一致性主要有以下两个关键问题： 第一个是如何保证读用户不能够读到不完整的数据（Read） 第二个是如何有效的保证写用户之间造成的冲突（Write） Key-problem 1：Read 针对第一个关键问题，为了防止单一节点崩溃导致不可用，Memery pool将索引分成了一个主要副本（Primary Slot）和多个备份副本（Backup Slot），读用户永远只读主副本的元数据作为结果，因为主副本有且仅有一份，保证所有读用户读到的都是一样的数据。 Key-problem 2：Write 正对第二个关键问题，即不同用户同时写入不同的值，本文提出了最后写者胜（last-writer-wins）的方法，怎么去理解这个方法呢，看这个图，Memery pool已经完成了复制，有主要副本和多个备份副本。此时有两个Client相对A这个K-V pair进行修改，Client1想修改为B，Client2想修改为C。 第一步，两个Client都会与主要副本进行通信，获取期望值（Expected）：A，然后对所有的备份副本进行通信，若此时备份副本插槽值和期望值（Expected）：A相同，说明这个备份副本未被修改，进行抢夺修改，若和A不同，则说明此时这个备份副本已被别的Client修改，就通信下一个备份副本。（相当于就是两个Client抢备份副本） 第二步，当两个Client通信完所有备份副本后，比较备份副本插槽的序列 第三步，使用以下规则确定最后的胜者 1.成功修改完所有的备份副本的Client为胜者 2.成果修改完大部分的备份副本的Client为胜者 3.若没有修改完大部分的备份副本的Client，则值最小的Client为胜者 以这个例子为例，备份副本插槽的序列为BBC，Client1为修改完大部分的备份副本的Client，成为胜者，将主要副本的插槽修改为B。 Design2：Two-Level Memory Management 这个设计的key idea 是将整个元数据管理计算任务拆分成简单计算任务和复杂计算任务两部分 当有一个请求过来时，将2GB空间分成块，内存结点将块分给Client，再有Client细致对这块内存进行管理。 具体来说：当Client A发起需要内存管理的请求（INSERT）时，MN首先选择一块数据块Block A，Block的大小一般为4KB、8KB、16KB，将其分配给发起请求的Client A，并添加一个index （Block A，Client A），明确Block A由Client A管理。然后Client A对Block A进行操作，在里面选择最适宜大小的位置，插入K-v pair。然后管理Block A里面的元数据。 这样MN承担管理大块的工作（计算量小），Clent承担小块的具体内存管理的工作（计算量小），此方法的同步开销也比较低，因为各Clent管理的不是全局的内存，而是分配给他的小块内存。 Design 3：Embedded Operation Log 这个设计的Key idea是：将日志信息嵌入到K-v pair中，减少传输开销。 元数据恢复一般通过日志来完成的，每完成一个操作，就在日志信息里面加一条。 日志序列必须和K-V pair的操作序列一致，所以单独发送日志信息，会需要额外的开销。 本文的主要思路是将日志和K-Vdata 一起打包传送，分配前就使用指针将logEntry按顺序串联起来（是一个双双向链表的数据结构），然后因为K-V pair是按顺序进行分配的，所以logEntry也具有了序列化。 ps：这部分理解的不是很懂，大家可以看看原文，了解细节。。。TAT Evaluation（只给了重点实验哈，更多请见paper） Platform 数据集分为两类： 第一类YSCB：就是混合数据集，各个操作（SEARCH UPDATA INSERT DELETE操作）的占比不同，其中 YSCB-A为写密集数据集 YSCB-C为读密集数据集 第二类Microbenchmark ：单一操作数据集，EARCH UPDATA INSERT DELETE 对照方法： 1.Clover：最新的半解耦K-V store架构，就是有元数据服务器哒（见background） 2.pDPM-Direct：以客户端为中心的远程内存管理，具有很大同步开销哒（见Challenge） Latency&amp;Throughput **Latency：**FUSE在INSERT和UPDATE上的表现最好，因为SNAPSHOT复制协议有限制的RTT。FUSE的SEARCH延迟略高于Clover，因为FUSE在单个RTT中读取哈希索引和KV对，这比仅在Clover中读取KV对慢。FUSE的DELETE延迟略高于pDPM Direct，因为FUSE在单个RTT中写入日志条目并读取哈希索引，这比仅在pDPM Direct中读取哈希索引要慢。 **Throughput：**pDPM Direct的吞吐量受到其远程锁的限制，随着客户端数量的增长，远程锁会导致大量的锁争用。对于Clover来说，尽管它消耗了更多的硬件资源，即8个额外的CPU内核和一个RNIC，但可扩展性仍然低于FUSE。这是因为元数据服务器的CPU处理能力限制了其吞吐量。相反，FUSE通过消除元数据服务器的计算瓶颈并有效解决与SNAPSHOT复制协议的冲突，提高了整体吞吐量。 主要是体现设计的总体效果。 YCSB-Throughput &amp; Two-level memory allocation performance **YCSB-Throughput：**当使用128个客户端将MN的数量从2个改变到5个时，具有写密集型工作负载（YCSB-a）和读密集型工作负荷（YCSB-C）的三种方法的吞吐量。pDPM Direct和Clover的吞吐量并没有增加，因为它们分别受到锁争用和元数据服务器有限计算能力的限制。对于FUSE，吞吐量随着内存节点数量从2个增加到3个而提高。由于总吞吐量受到计算节点数量的限制，因此没有进一步的吞吐量改进。 **Two-level memory allocation performance：**为了显示两级内存分配方案的有效性，我们将FUSE与以MN为中心的内存分配方案进行了比较，如图所示。由于MN上的计算能力有限，YCSB-A吞吐量下降了90.9%，而YCSB-C吞吐量保持不变，因为只读设置中不涉及内存分配。 主要是体现第二个设计的作用 Recover from Crashed Clients **Recover from Crashed Clients：**为了评估客户端从故障中恢复的效率，在更新1000次后崩溃并恢复客户端。FUSE从客户端故障中恢复需要177毫秒。内存注册和连接重新建立占总恢复时间的92%。日志遍历和KV请求恢复只占恢复时间的4%，这意味着日志遍历的开销是可以承受的。（第三个设计总体不是很明白orz） Conclusion 最后是一个我自己对这篇paper的总结，我感觉这篇paper还是蛮interesting的","categories":[{"name":"论文阅读笔记","slug":"论文阅读笔记","permalink":"https://maple-meo.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Storage","slug":"Storage","permalink":"https://maple-meo.github.io/tags/Storage/"},{"name":"FAST","slug":"FAST","permalink":"https://maple-meo.github.io/tags/FAST/"},{"name":"K-V Store","slug":"K-V-Store","permalink":"https://maple-meo.github.io/tags/K-V-Store/"}]}],"categories":[{"name":"一些教程","slug":"一些教程","permalink":"https://maple-meo.github.io/categories/%E4%B8%80%E4%BA%9B%E6%95%99%E7%A8%8B/"},{"name":"论文阅读笔记","slug":"论文阅读笔记","permalink":"https://maple-meo.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://maple-meo.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"内存模块编程","slug":"内存模块编程","permalink":"https://maple-meo.github.io/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9D%97%E7%BC%96%E7%A8%8B/"},{"name":"Git","slug":"Git","permalink":"https://maple-meo.github.io/tags/Git/"},{"name":"基础技能","slug":"基础技能","permalink":"https://maple-meo.github.io/tags/%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/"},{"name":"Storage","slug":"Storage","permalink":"https://maple-meo.github.io/tags/Storage/"},{"name":"FAST","slug":"FAST","permalink":"https://maple-meo.github.io/tags/FAST/"},{"name":"K-V Store","slug":"K-V-Store","permalink":"https://maple-meo.github.io/tags/K-V-Store/"}]}